# 벡터연산

## 벡터화 - 벡터 연산
- 같은 형태(shape)의 배열(벡터, 행렬)간의 연산은 같은 index의 원소끼리 연산
    - **Element-wise(원소별) 연산** 이라고도 한다.
    - 배열간의 연산시 배열의 형태가 같아야 한다.
    - 배열의 형태가 다른 경우 Broadcast 조건에 맞으면 연산 가능

- 벡터, 행렬과 스칼라간 연산  / 벡터, 행렬의 연산
- 사진 1 ###################################################
- 사용예제
```python
import numpy as np
# 배열과 scalar 간의 연산
x = np.array([1,2,3])
print(x)
print(x+10)
print(x*10)
print(x>2)
print(10/x)
print(~(x>2)) # not : ~(비교연산)
print((x>1) & (x<5)) # (비교연산) `&` / `|`(비교연산) -- numpy/pandas : `&`, `|`, `~`
# [1 2 3]
# [11 12 13]
# [10 20 30]
# [False False  True]
# [ True False False]
# [10.          5.          3.33333333]
# [ True  True False]
# [False  True  True]

x = np.array([1,2,3])
z = np.array([1,2,3,4,5])
x + z # (3,) + (5,) => 다른 shape의 배열간에는 연산이 안됨
```
## 내적(Dot product)
- `@` 연산자 또는 `numpy.dot(벡터/행렬, 벡터/행렬)` 함수 사용
### 1. 벡터간의 내적
- 같은 index의 원소끼리 곱한 뒤 결과를 모두 더한다.
- 벡터간의 내적의 결과는 scala가 된다.
- 조건
    - 두 벡터의 차원(원소릐 개수)가 같아햐 한다.
    - **앞 벡터**는 `행벡터` **뒤 벡터**는 `열벡터`
        - numpy에서는 vector끼리 연산시 **앞 벡터**는 `행벡터`, **뒤 벡터**는 `열벡터`로 인식해 처리한다.
- 사진 2 ###################################################
- 사용예제
```python
import numpy as np

x = np.array([1,2,3])
y = np.array([4,5,6])
print(x @ y)
print(np.dot(x, y))
# 32
# 32

# 1차원 배열의 경우 동일한 shape의 배열끼리 연산가능
```
### 2. 행렬간의 내적
- **앞 행렬**의 `행`과 **뒤 행열**의 `연`간에 내적
- 행렬과 행렬을 내적하면 결과는 행령이 나온다.
- 앞 행렬의 열수와 뒤 행렬의 행수가 같아야 한다. 
    - (3 x 2) 와 (2 x 5) = (3 x 5)
    - (1 x 5) 와 (5 x 1) = (1 x 1)
- 사진 3 ###################################################
- 사용예제
```python
가격 : 사과 = 2,000원, 귤 = 1,000원, 수박 = 10,000원   
A 구매자 : 사과 10개, 귤 5개, 수박 10개   
B 구매자 : 사과 5개, 귤 20개, 수박 10개   
C 구매자 : 사과 50개, 귤 10개, 수박 1개
총 금액?

import numpy as np

l = [
    [10,5,10],
    [5,20,10],
    [50,10,1]
]
customers = np.array(l)
fruit_price = np.array([2000, 1000, 10000])


```













