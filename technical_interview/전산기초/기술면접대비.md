# 기술면접 대비


## 1. Thread란?
- Thread란 Process내에서 실제로 작업을 수행하는 주체를 의미
- 모든 Process에는 한 개 이상의 Thread가 존재하여 작업을 수행한다.
- 또한 두 개 이상의 Thread를 가지는 Process를 Multi-Thread Process라고 한다.

> ### Multi-Thread란?
> - 하나의 응용프로그램을 여러 개의 Thread로 구성하고, 각 Thread로 하여금 하나의 작업을 처리하도록 하는 것
> - Web Server는 대표적인 Multi-Thread 응용 프로그램이다.
> 
> ### 장점
> - 시스템 자원 소모 감소(자원의 효율성 증대)
> - 시스템 처리량 증가(처리 비용 감소) : Tread 사이의 작업량이 작아 **Context Switching**이 빠름
> - 간단한  통신 방법으로 인한 프로그램 응답 시간 단축 : Tread는 process 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 젃다.
> 
> ### 단점
> - 주의 깊은 설계가 필요
> - 디버깅이 까다롭다.
> - 단일 Process 시스템의 경우 효과를 기대하기 어렵다.
> - Multi-Thread의 경우 자원 공유의 문제가 발생(**동기화** 문제)
> 
> ##### Context Switching
> - Process의 상태 정보를 저장하고 복원하는 일련의 과정
> - 동작 중인 Process가 대기하면서 해당 Process의 상태를 보관하고, 대기하고 있던 다음 순번의 Process가 동작하면서 이전에 보관했던 Process 상태를 복구하는 과정
> - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정
>
> ##### Tread 동기화 방법의 종류
> - Mutex(뮤텍스)
> - Semaphore(세마포어)
> - Monitor(모니터)

## 2. Garbage Collector란?
```java
String[] array = new String[3];

array[0] = '0';
array[1] = '1';
array[2] = '2';

array = new String[]{"G", "C"};
```
- 위 코드에서 String 배열이 할당되기 전에 할당된 0, 1, 2는 주소를 읽어버리게 된다.
- 이렇게 주소를 읽어버려 사용할 수 없는 메모리가 '정리되지 않은 메모리'이다.
- Garbage Collector는 메모리가 부족할 때 쓰레기, 즉 Garbage를 정리해주는 프로그램
> ### (+) Stop the world
> - Garbage Collector 실행을 위해 JVM이 애플리케이션 실행을 멈추는 것
> - Garbage Collector가 실행될 때는 GC를 실행하는 Thread를 제외한 모든 Tread들이 작업을 멈춤
> - Garbage Collector작업이 완료된 이후에 중단했던 작업을 다시 시작

## 3. Session과 Cookie
> - 쿠키와 세션을 사용하는 이유는 HTTP(Hypertext Transfer Protocol)의 비연결성(Connectionless)과 비상태성(Stateless)이라는 특징을 보완하기 위해 사용됨
> - **비연결성**은 Client가 서버에 요청(request)을 했을 때, 그 요청에 맞는 응답(reponse)을 보낸 후 연결을 끊는 처리방식
> - **비상태성**은 Client의 상태 정보를 가지지 않는 서버 처리 방식
>   - 첫번째 통신에서 Client와 Data를 주고 받았다 해도, 두번째 통신에서는 이전 데이터를 유지하지 않는다.
> - Server와 Client가 통신을 할 때 통신이 연속적으로 이어지지 않고 끊어진다면 서버는 클라이언트가 누구인지 계속 인증 해줘야함
> - 하지만 이러한 동작은 매우 귀찮고 번거롭고 동시에 웹페이지의  로딩을 느리게 만드는 요인이 된다.
> - 이러한 번거로움을 해결하는 방법이 바로 쿠키와 세션이다.
### Cookie(쿠키)
- HTTP의 일종으로 사용자가 어떤 웹 사이트를 방문할 때 생성되는 정보를 담은 임시 파일
- 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터를 말한다.
- 쿠키의 데이터 형태는 Key, Value로 구성되고 String 형태로 이루어져 있다.
- 브라우저마다 저장되는 쿠키는 다르며 서버에서는 브라우저가 다르면 다른 사용자로 인식

> #### 쿠키의 특징
> - 이름, 값, 만료일, 경로 정보로 구성
> - Client에 총 300개의 Cookie를 저장할 수 있다.
> - 하나의 도메인 당 20개의 Cookie를 가질 수 있다.
> - 하나의 Cookie는 4KB까지 저장이 가능하다.
> 
> #### 쿠키의 동작 순서
> - 클라이언트가 페이지 요청(사용자 웹 사이트 접근)
> - 웹 서버는 쿠키를 생성
> - 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때 같이 Client에게 돌려준다.
> - 넘겨 받은 쿠키는 Client가 가지고 있다가 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
> - 동일 사이트 재방문 시, Client의 PC에 해당 쿠키가 있을 경우 요청 페이지와 함께 쿠키를 전송한다.
> 
> #### 사용 예시
> - 방문했던 사이트에 다시 방문했을 때 아이디와 비밀번호 자동 입력
> - 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크
> 
> #### 단점
> - 서버가 가지고 있는 것이 아닌 사용자에게 저장되기 때문에 임의로 고치거나 지울 수 있고, 가로채기도 쉬워 보안이 취약
>   - 이러한 단점을 보완해주는 것이 **세션**

### Session(세션)
- 일정 시간동안 같은 사용자(browser)로부터 들어오는 일련의 요구사항을 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술
- 세션 아이디는 웹 브라우저 당 1개 씩 생성되어 웹 컨테이너에 저장되며 브라우저 종료 시 소멸
- 로그인한 사용자에 대해서만 세션을 생성하는 것이 아니라 로그아웃 시 새로운 사용자로 인식하여 새로운 세션이 생성

> #### 세션의 특징
> - 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
> - 웹 서버에 저장되는 쿠키(=세션 쿠키)
> - 브라우저를 종료하거나, 서버에서 세션을 삭제했을 때만 삭제가 됨으로 쿠키보다 비교적 보안이 좋다.
> - 저장 데이터에 제한이 없다.
> - 각 Client에 고유 Session ID를 부여한다. 이 Session ID로 Client를 구분하여 각 Client의 요구에 맞는 서비스를 제공
>
> #### 세션의 동작 순서
> - Client가 페이지를 요청한다.(사용자가 웹사이트 접근)
> - 서버는 접근한 Client의 Request-Header 필드인 Cookie를 확인하고, Client가 해당 Session ID를 보냈는지 확인
> - Session ID가 존재하지 않는다면, 서버는 Session ID를 생성해 Client에게 돌려준다.
> - 서버에서 Client로 돌려준 Session ID를 쿠키를 사용하여 서버에 저장
> - Client 접속 시 이 세션 쿠키를 이용하여 Session ID값을 서버에 전달
>
> #### 사용 예시
> - 화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

### 쿠키와 세션 차이 비교
|  | 쿠키(Cookie) | 세션(Session) |
| -- | -- | -- |
| 저장 위치 | 클라이언트(=접속자 PC) | 웹 서버 |
| 저장 형식 | Text | Object |
| 만료 시점 | 쿠키 저장 시 설정 (브라우저가 종료되더라도 만료시점이 지나지 않으면 자동 삭제되지 않음) | 브라우저 종료 시 삭제(기간 지정 가능) |
| 사용하는 자원(리소스) | 클라이언트 리소스 | 웹 서버 리소스 |
| 용량 제한 | 총 300개, 하나의 도메인 당 20개, 하나의 쿠키 당 4KB | 서버가 허용하는 한 용량제한 없음 |
| 속도 | 세션보다 빠름 | 쿠키보다 느림 |
| 보안 | 세션보다 안좋음 | 쿠키보다 좋음 | 

## Stack과 Queue
### Stack
- 스택은 '쌓다'라는 의미를 가지고 있다. 즉, 데이터를 차곡차곡 쌓아올린 형태로 자료를 구성
- 스택은 Last-in-First-Out의 자료구조이다.
- 스택에서의 데이터 삽입  연산을 Push, 삭제 연산을 pop이라 한다. 이렇게 삽입과 삭제가 일어나는 위치를 Top이라 한다.
- 비어있는 스택에서 원소를 추출하려고 할 때 Stack underflow라고 하며, 스택이 넘치는 경우는 Stack overflow라고 한다.
> #### 스택의 활용
> - 웹 브라우저의 방문기록(뒤로가기) - 가장 나중에 열린 페이지부터 다시 보여준다.
> - 역순 문자열 만들기 - 가장 나중에 입력된 문자부터 출력
> - 실행 취소(undo) - 가장 나중에 입력된 문자부터 출력
> - 후휘 표기법 계산
> - 수식의 괄호 검사(연산자 우선순위 표현을 위한 괄호 검사)
> - 깊이 우선 탐색(DFS) 구현

### Queue
- 큐는 First-in-First-out의 자료구조이다.
- 한 쪽 끝에서는 삽입 작업을, 다른 한 쪽 끝에서는 삭제 작업이 이루어진다. 이 때 삭제 연산만 수행되는 곳을 Front, 삽입 연산만 이루어지는 곳을 rear라고 한다.
- 큐의 rear에서 이루어지는 삽입 연산을 enQueue, Front에서 이루어지는 삭제 연산을 dequeue라고 부른다.
> #### 큐의 활용
> - 우선순위가 같은 작업 예약(프린터의 인쇄 대기열)
> - 은행 업무
> - 콜센터 고객 대기시간
> - 프로세스 관리
> - 너비 우선 탐색(BFS) 구현
> - 캐시 구현

## Anomaly(이상) 현상
- 좋은 관계형 데이터베이스를 설계하기 위해서는 정보의 이상현상이 생기지 않도록 고려해야한다.
- 이상 현상은 갱신 이상, 삽입 이상, 삭제 이상으로 구성된다.
>  - 갱신 이상 : 릴레이션에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상
>  - 삽입 이상 : 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상
>  - 삭제 이상 : 릴레이션에 데이터를 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상
- 이러한 이상 현상을 정규화 과정을 통해 해결할 수 있다. 속성들 간의 종속관계를 분석한 후 여러개의 릴레이션으로 분해하는 과정을 정규화(Normalization)이라고 한다.
